#' Compare two graphs
#'
#' From two graphs generated by \code{\link{graph_from_matrix()}} or
#' \code{\link{graph_from_links_nodes()}}, displays two graphs
#' with the same legend (edge weights and size and node degrees)
#' NB : if you use families, make sure they have the same families
#' (this can be done by generating a same palette for both graphs using
#' \code{\link{family_palette()}})
#'
#' @param graph1 : the first graph
#' @param graph2 : the second graph
#' @param titles (optional) : list of 2 : the two title of the graphs.
#' Default are the graph titles from \code{\link{graph_from_matrix()}}
#' or \code{\link{graph_from_links_nodes()}}.
#' @param position : should the graphs be displayed vertically (use
#' \code{vertical}, default) or horizontally (use \code{horizontal}).
#' @param n_nodes : the number of nodes to be displayed in the legend.
#' R will do its best to be around this number.
#' @param n_weights : the number of weights to be displayed in the legend.
#' R will do its best to be around this number.
#' @param unique_legend : should there be a unique legend (default is TRUE)
#' BE CAREFUL to have the same family colors if you use families/
#'
#' @importFrom rlang .data
#' @importFrom labeling extended
#' @import cowplot
#' @import ggplot2
#' @import igraph
#' @import ggraph
#' @export
compare_graphs <- function(graph1,
                           graph2,
                           titles = NULL,
                           position = c("vertical", "horizontal"),
                           n_nodes = 5,
                           n_weights = 5,
                           unique_legend = TRUE) {

  if (is.null(graph1$igraph) || is.null(graph1$net) || is.null(graph1$deg) ||
      is.null(graph2$igraph) || is.null(graph2$net) || is.null(graph2$deg)) {
    stop("Can only compare graphs generated by foodingraph")
  }

  position <- match.arg(position)

  #-----------
  # PART 1 : Nodes (degrees)
  #-----------

  # Determine the appropriate range and breaks for node degree values
  graph1_degrees <- degree(graph1$igraph)
  graph2_degrees <- degree(graph2$igraph)

  range_degrees1 <- c(min(graph1_degrees), max(graph1_degrees))
  range_degrees2 <- c(min(graph2_degrees), max(graph2_degrees))

  range_degrees <- c(min(range_degrees1, range_degrees2),
                     max(range_degrees1, range_degrees2))

  breaks_degrees <- extended(range_degrees[1], range_degrees[2], n_nodes)
  # To remove unexpected behaviour that can show node degrees not rounded
  breaks_degrees <- unique(round(breaks_degrees))

  #-----------
  # PART 2 : Edges (weights and alpha)
  #-----------

  # Determine the appropriate range and breaks for edge width values
  graph1_edges <- E(graph1$igraph)
  graph2_edges <- E(graph2$igraph)

  range_weights1 <- c(min(graph1_edges$weight), max(graph1_edges$weight))
  range_weights2 <- c(min(graph2_edges$weight), max(graph2_edges$weight))

  range_weights <- c(min(range_weights1, range_weights2),
                     max(range_weights1, range_weights2))

  breaks_weights <- extended(range_weights[1], range_weights[2], n_weights)

  #-----------
  # PART 3 : Reconstruct the graph
  #-----------

  # Altering the graphs
  graph1$net <- suppressMessages(
    graph1$net +
      # Edge width and alpha
      scale_edge_alpha_continuous(name = "Edge weight", range = c(0.4,1),
                                  breaks = breaks_weights,
                                  limits = range_weights) +
      scale_edge_width_continuous(name = "Edge weight", range = c(0.2,2),
                                  breaks = breaks_weights,
                                  limits = range_weights) +
      # Node degree
      scale_size_continuous(name = "Node degrees", range = c(1,10),
                            breaks = breaks_degrees,
                            limits = range_degrees)
  )

  graph2$net <- suppressMessages(
    graph2$net +
      # Edge width and alpha
      scale_edge_alpha_continuous(name = "Edge weight", range = c(0.4,1),
                                  breaks = breaks_weights,
                                  limits = range_weights) +
      scale_edge_width_continuous(name = "Edge weight", range = c(0.2,2),
                                  breaks = breaks_weights,
                                  limits = range_weights) +
      # Node degree
      scale_size_continuous(name = "Node degrees", range = c(1,10),
                            breaks = breaks_degrees,
                            limits = range_degrees)
  )

  # Retrieve the legend


  # Arrange in a grid
  nrow_grid <- ifelse(position == "vertical", 2, 1)
  ncol_grid <- ifelse(position == "vertical", 1, 2)
  align_grid <- ifelse(position == "vertical", "v", "h")


  if (unique_legend == TRUE && position == "vertical") {
    final_graph <- plot_grid(
      graph1$net + theme(legend.position = "none"),
      NULL,
      graph2$net + theme(legend.position = "none"),
      labels = c(titles[1], "", titles[2]),
      ncol = 1,
      rel_heights = c(1, 0.3, 1),
      align = "v",
      axis = "lr"
    )

    legend_plot <- get_legend(graph1$net + theme(legend.position = "bottom"))
    final_graph <- final_graph + draw_grob(legend_plot, 1/3.3, 0, .3/3.3, 1)

  } else if (unique_legend == TRUE && position == "horizontal") {
    final_graph <- plot_grid(
      graph1$net + theme(legend.position = "none"),
      NULL,
      graph2$net + theme(legend.position = "none"),
      labels = c(titles[1], "", titles[2]),
      ncol = 3,
      rel_widths = c(1, 0.3, 1),
      align = "h",
      axis = "tb"
    )

    legend_plot <- get_legend(graph1$net)
    final_graph <- final_graph + draw_grob(legend_plot, 1/3.3, 0, .3/3.3, 1)
  } else {
    final_graph <- plot_grid(
      graph1$net,
      graph2$net,
      labels = titles,
      ncol = ncol_grid,
      nrow = nrow_grid,
      align = align_grid,
      axis = "bl"
    )
  }

  # Define classess
  class_position <- ifelse(position == "vertical",
                           "foodingraph_vertical",
                           "foodingraph_horizontal")

  class(final_graph) <- c(class(final_graph), "foodingraph_compare",
                          class_position)

  final_graph
}
